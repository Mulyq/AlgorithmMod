## 快速排序

```cpp
void quick_sort(vector<int> &a, int l, int r) {
    if(l >= r) return;
    int x = a[l + r >> 1], i = l - 1, j = r + 1;
    while(i < j) {
        do(i ++); while(a[i] < x);
        do(j --); while(a[j] > x);
        if(i < j) swap(a[i], a[j]);
    }
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}
```

## 归并排序

```cpp
void merge_sort(vector<int> &a, int l, int r) {
    vector<int> tmp;
    if(l >= r) return ;
    int mid = l + r >> 1;
    int i = l, j = mid + 1;
    merge_sort(a, l, mid), merge_sort(a,mid + 1, r);
    while(i <= mid && j <= r) {
        if(a[i] < a[j]) tmp.push_back(a[i ++]);
        else tmp.push_back(a[j ++]);
    }
    while(i <= mid) tmp.push_back(a[i ++]);
    while(j <= r) tmp.push_back(a[j ++]);
    for(int i = 0, j = l; i < tmp.size(); i ++) {
        a[j ++] = tmp[i];
    }
}
```
## 第k大的数

```cpp
int quick_sort(int q[],int l,int r,int k) {
    if(l >= r) return q[l];
    int x = q[l + r >> 1],i = l - 1,j = r + 1;
    while(i < j) {
        do i ++; while(q[i] < x);
        do j --; while(q[j] > x);
        if(i < j) swap(q[i],q[j]); 
    }
    if(j - l + 1 >= k) return quick_sort(q,l,j,k);
    else rquick_sort(q,j + 1,r,k - (j - l + 1));
}
```

## 逆序对的数量

```cpp
ll merge_sort(vector<int> &q, int l, int r) {
    if(l >= r) return 0;
    int mid = l + r >> 1;
    ll rec = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    vector<int> temp;
    while(i <= mid  && j <= r) {
        if(q[i] <= q[j]) {
            temp.push_back(q[i ++]);
        }
        else {
            temp.push_back(q[j ++]);
            rec += mid - i + 1;
        }
    }
    while(i <= mid) temp.push_back(q[i ++]);
    while(j <= r) temp.push_back(q[j ++]);
    for(int i = l, k = 0; i <= r; i ++, k ++) q[i] = temp[k];
    return rec;
}
```