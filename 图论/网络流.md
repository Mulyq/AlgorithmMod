## 最大流

#### FF
```cpp
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int n, m, s, t;
struct Edge {
    int to, cap, rev;
};
vector<Edge> e[MAXN];
bool vis[MAXN];
void add_e(int from, int to, int cap) {
    e[from].push_back({to, cap, (int)e[to].size()});
    e[to].push_back({from, 0, (int)e[from].size() - 1});
}

int dfs(int u, int t, int f) {
    if(u == t) return f;
    vis[u] = 1;
    for(auto &[v, c, rev] : e[u]) {
        if(!vis[v] && c > 0) {
            int d = dfs(v, t, min(f, c));
            if(d > 0) {
                c -= d;
                e[v][rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

ll max_flow(int s, int t) {
    ll flow = 0;
    while (1) {
        for(int i = 0; i <= n; i ++) {
            vis[i] = 0;
        }
        int temp = dfs(s, t, INF);
        if(temp) flow += temp;
        else return flow;
    }
    
}
```

#### Dinic
```cpp
int n, m, s, t;
struct Edge {
    int to, cap, rev;
};
vector<Edge> e[MAXN];
int iter[MAXN];
int level[MAXN];

void add_e(int from, int to, int cap) {
    e[from].push_back({to, cap, (int)e[to].size()});
    e[to].push_back({from, 0, (int)e[from].size() - 1});
}

int dfs(int u, int t, int f) {
    if(u == t) return f;
    for(int &i = iter[u]; i < e[u].size(); i ++) {
        auto &[v, c, rev] = e[u][i];
        if(level[u] < level[v] && c > 0) {
            int d = dfs(v, t, min(f, c));
            if(d > 0) {
                c -= d;
                e[v][rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}
void bfs() {
    for(int i = 0; i <= n; i ++) {
        level[i] = -1;
    }
    queue<int> q;
    level[s] = 0;
    q.push(s);
    while(q.size()) {
        int u = q.front();
        q.pop();
        for(auto &[v, c, rev] : e[u]) {
            if(level[v] == -1 && c > 0) {
                level[v] = level[u] + 1;
                q.push(v);
            }
        }
    }
}
ll max_flow(int s, int t) {
    ll flow = 0;
    while (1) {
        bfs();
        if(level[t] < 0) return flow;
        for(int i = 0; i <= n; i ++) {
            iter[i] = 0;
        }
        int f;
        while((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
    
}
```

## 二分图的最大匹配

- 等于二分图的最小点覆盖
#### 匈牙利算法
```cpp
int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
vector<vecotr<int>> G;
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i) {
    for(int v : G[i]) if(!vis[v]) {
        vis[v] = 1;
        if(p[v] == 0 || match[p[v]]) {
            p[v] = i;
            return 1;
        }
    }
    return 0;
    for (int j = 1; j <= N; j ++)
        if (Map[i][j] && !vis[j]) //有边且未访问
        {
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])) //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
            {
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian()
{
    int cnt = 0;
    for (int i = 1; i <= M; ++i)
    {
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
```
## 最大流

#### FF
```cpp
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int n, m, s, t;
struct Edge {
    int to, cap, rev;
};
vector<Edge> e[MAXN];
bool vis[MAXN];
void add_e(int from, int to, int cap) {
    e[from].push_back({to, cap, (int)e[to].size()});
    e[to].push_back({from, 0, (int)e[from].size() - 1});
}

int dfs(int u, int t, int f) {
    if(u == t) return f;
    vis[u] = 1;
    for(auto &[v, c, rev] : e[u]) {
        if(!vis[v] && c > 0) {
            int d = dfs(v, t, min(f, c));
            if(d > 0) {
                c -= d;
                e[v][rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

ll max_flow(int s, int t) {
    ll flow = 0;
    while (1) {
        for(int i = 0; i <= n; i ++) {
            vis[i] = 0;
        }
        int temp = dfs(s, t, INF);
        if(temp) flow += temp;
        else return flow;
    }
    
}
```

#### Dinic
```cpp
int n, m, s, t;
struct Edge {
    int to, cap, rev;
};
vector<Edge> e[MAXN];
int iter[MAXN];
int level[MAXN];

void add_e(int from, int to, int cap) {
    e[from].push_back({to, cap, (int)e[to].size()});
    e[to].push_back({from, 0, (int)e[from].size() - 1});
}

int dfs(int u, int t, int f) {
    if(u == t) return f;
    for(int &i = iter[u]; i < e[u].size(); i ++) {
        auto &[v, c, rev] = e[u][i];
        if(level[u] < level[v] && c > 0) {
            int d = dfs(v, t, min(f, c));
            if(d > 0) {
                c -= d;
                e[v][rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}
void bfs() {
    for(int i = 0; i <= n; i ++) {
        level[i] = -1;
    }
    queue<int> q;
    level[s] = 0;
    q.push(s);
    while(q.size()) {
        int u = q.front();
        q.pop();
        for(auto &[v, c, rev] : e[u]) {
            if(level[v] == -1 && c > 0) {
                level[v] = level[u] + 1;
                q.push(v);
            }
        }
    }
}
ll max_flow(int s, int t) {
    ll flow = 0;
    while (1) {
        bfs();
        if(level[t] < 0) return flow;
        for(int i = 0; i <= n; i ++) {
            iter[i] = 0;
        }
        int f;
        while((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
    
}
```

## 二分图的最大匹配

- 等于二分图的最小点覆盖
#### 匈牙利算法
```cpp
int M, N;            //M, N分别表示左、右侧集合的元素数量
int Map[MAXM][MAXN]; //邻接矩阵存图
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i) {
    for (int j = 1; j <= N; j ++)
        if (Map[i][j] && !vis[j]) //有边且未访问
        {
            vis[j] = true;                 //记录状态为访问过
            if (p[j] == 0 || match(p[j])) //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
            {
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
        }
    return false; //循环结束，仍未找到匹配，返回匹配失败
}
int Hungarian()
{
    int cnt = 0;
    for (int i = 1; i <= M; ++i)
    {
        memset(vis, 0, sizeof(vis)); //重置vis数组
        if (match(i))
            cnt++;
    }
    return cnt;
}
```
## 最大流

#### FF
```cpp
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int n, m, s, t;
struct Edge {
    int to, cap, rev;
};
vector<Edge> e[MAXN];
bool vis[MAXN];
void add_e(int from, int to, int cap) {
    e[from].push_back({to, cap, (int)e[to].size()});
    e[to].push_back({from, 0, (int)e[from].size() - 1});
}

int dfs(int u, int t, int f) {
    if(u == t) return f;
    vis[u] = 1;
    for(auto &[v, c, rev] : e[u]) {
        if(!vis[v] && c > 0) {
            int d = dfs(v, t, min(f, c));
            if(d > 0) {
                c -= d;
                e[v][rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

ll max_flow(int s, int t) {
    ll flow = 0;
    while (1) {
        for(int i = 0; i <= n; i ++) {
            vis[i] = 0;
        }
        int temp = dfs(s, t, INF);
        if(temp) flow += temp;
        else return flow;
    }
    
}
```

#### Dinic
```cpp
int n, m, s, t;
struct Edge {
    int to, cap, rev;
};
vector<Edge> e[MAXN];
int iter[MAXN];
int level[MAXN];

void add_e(int from, int to, int cap) {
    e[from].push_back({to, cap, (int)e[to].size()});
    e[to].push_back({from, 0, (int)e[from].size() - 1});
}

int dfs(int u, int t, int f) {
    if(u == t) return f;
    for(int &i = iter[u]; i < e[u].size(); i ++) {
        auto &[v, c, rev] = e[u][i];
        if(level[u] < level[v] && c > 0) {
            int d = dfs(v, t, min(f, c));
            if(d > 0) {
                c -= d;
                e[v][rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}
void bfs() {
    for(int i = 0; i <= n; i ++) {
        level[i] = -1;
    }
    queue<int> q;
    level[s] = 0;
    q.push(s);
    while(q.size()) {
        int u = q.front();
        q.pop();
        for(auto &[v, c, rev] : e[u]) {
            if(level[v] == -1 && c > 0) {
                level[v] = level[u] + 1;
                q.push(v);
            }
        }
    }
}
ll max_flow(int s, int t) {
    ll flow = 0;
    while (1) {
        bfs();
        if(level[t] < 0) return flow;
        for(int i = 0; i <= n; i ++) {
            iter[i] = 0;
        }
        int f;
        while((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
    
}
```

## 二分图的最大匹配

- 等于二分图的最小点覆盖
#### 匈牙利算法
```cpp
int n, m;            //M, N分别表示左、右侧集合的元素数量
vector<vector<int>> G;
int p[MAXN];         //记录当前右侧元素所对应的左侧元素
bool vis[MAXN];      //记录右侧元素是否已被访问过
bool match(int i) {
    bool ok = 0;
    for(int v : G[i]) if(!vis[v]) {
        vis[v] = 1;
        if(!ok && (p[v] == 0 || match(p[v]))) {
            p[v] = i;
            ok = 1;
        }
        vis[v] = 0;
    }
    return ok;
}
int Hungarian() {
    int cnt = 0;
    for(int i = 1; i <= n; ++i) {
        memset(vis, 0, sizeof vis);
        if(match(i)) {
            cnt ++;
        }
    }
    return cnt;
}
```